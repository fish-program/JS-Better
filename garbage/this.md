## implicit `this` bind rules
为什么会有 `this`?
一开始面对对象语言发展的时候，有这样的需求：
- 在构造函数中获得对刚刚创建的对象的引用
- 在对象的方法中获得当前对象的引用

在解决这个问题的时候，我觉得Python的语法不错：
``` py
class Person:
    def __init__(self, birthyear):
        self.birthyear = birthyear
    
    def logAge(self):
        print(2018 - self.birthyear) 

p = Person(1999)
p.logAge() # 19
```
我觉得这种写法就不错，把每个函数的第一个参数作为是当前对象的引用。

但是多数编程语言采取了另一中约定，风格：构造函数或者方法中通过this关键字来表达这种引用。
``` java
public Person{
  void Person(String name){
    this.name = name
  }
}
```
其实无论哪种做法，都行。

但是在JS中有一个问题，就是说函数式一等公民，一个函数它：
- 可以当作普通函数来调用
- 也可以当做一个构造函数来调用
- 而且还可以作为一个对象的方法来调用

那如果是前两者，那就像我们之前所说的话，this规则就是很清楚。
但是呢，这就出现一个问题，因为JS它语言层面上他们没有区分这三种类型的函数。定义函数的时候，你也不知道他会被以哪种方式调用

如果一个函数中存在this关键字，但又被当做普通函数来调用，那么this指向哪里?

此处省略两千万字。毫不夸张，网路上都把这个说烂了，两千万万字绝对有。

但是我想说的是，这没有意义。这种this规则已经脱离的它的本源，就像是一个空中楼阁。我在项目以及阅读开源库的经验中，从来没有必须使用这个特性的时候。这存粹是这个语言的糟粕。
ES规定了这个除了装逼没什么卵用你的规则，一群人用这个没什么卵用的规则装逼。

真的很蠢，很傻比。有这个时间还不如看看设计模式，重构下代码。除了互相伤害和装逼，我真的没见过这种垃圾规则的使用场景。

其实Function.prototype.bind .call .apply 都没什么价值，真的需要传递`this object`的时候，给函数多传递一个参数就行了。

在说说箭头函数，不就是换了一个this绑定的规则？通过词法作用域绑定。真的没意义。

总结：
- 可以在构造函数、方法中用this
- 适当可以用.bind .call 但是其实没必要

- 永远不要使用隐式this绑定
  - 这种情况下，箭头函数和普通函数也就没有区别了